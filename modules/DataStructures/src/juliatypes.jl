# Extensions of methods to jl native types

# Ranges are immutable, so let's just use our vectors.
empty(x::AbstractRange) = emptyvector
empty(x::Base.Vector) = []

count(v::Base.Vector) = length(v)
count(xs::Tuple) = length(xs)

"""
Creates a *new* vector containing all elements of `v` appended with `x`.

N.B.: This can be VERY slow for large aggregations, ram usage growing
quadratically with N (plus big constants).

If you need immutability, use persistent vectors. If you need speed, use
`into!`. This is only here for completeness and to prevent unexpected failures
in performance agnostic code.
"""
function conj(v::Base.Vector, x)
  if v == []
    # Use x's type instead of `Any` if possible.
    [x]
  else
    vcat(v, [x])
  end
end

rest(v::Base.Array) = v[2:end]
rest(v::UnitRange) = rest(Base.Vector(v))
rest(v::Tuple) = v[2:end]

conj(m::Map, v::Base.Vector) = assoc(m, v[1], v[2])
conj(m::Map, e::NTuple{2, Any}) = assoc(m, e[1], e[2])

function get(v::Base.Vector, i)
  if isdefined(v, Int(i))
    v[i]
  else
    nothing
  end
end

ireduce(f, init, coll::AbstractRange) = Base.reduce(f, coll; init)
ireduce(f, init, coll::Array) = Base.reduce(f, coll; init)
ireduce(f, init, coll::Tuple) = Base.reduce(f, coll; init)

Base.convert(::Type{Vector}, xs::Tuple) = vec(xs)
Base.convert(::Type{Vector}, xs::Base.Vector) = vec(xs)
Base.convert(::Type{Vector}, xs::UnitRange) = vec(xs)

struct InitOnly end

"""
Sets the accumulator arg to a Base.Vector whose eltype is the type of the first
element generated by the xform chain to which this is appended. If the ensuing
values are not all of the same type, replaces the accumulator again with a
Base.Vector{Any} and boxes everything.
"""
function typeset()
  function(emit)
    function inner()
      emit()
    end
    function inner(x)
      emit(x)
    end
    function inner(r::InitOnly, n)
        emit(Base.Vector{typeof(n)}(), n)
    end
    function inner(r::Base.Vector{T}, n::T) where T
        emit(r, n)
    end
    function inner(r, n)
      @warn "Heterogeneous types, boxing."
      emit(Base.Vector{Any}(r), n)
    end
  end
end

"""
Mutates `to` by `push!`ing each element emitted by the application of `xform` to
`from`.

Intended for use with a new empty Base.Vector each time, but that can be
manipulated.

if `infertype` is `true` (default), then try to infer the eltype of the output
collection and avoid boxing. If you know that the type of the first element
produced will be unrepresentative or that `Any` is the correct eltype for the
output collection, then set `infertype` to `false` to avoid the useless
overhead.
"""
function into!(to::Base.Vector, xform, from, infertype=true)
  if isempty(to) && eltype(to) == Any && infertype
    # Try to infer the output type of xform so that we don't box unnecessarily
    # Note that this brings overhead even in the case where we need to box
    # anyway, but the overhead is small and the cost of boxing bits types is
    # huge.
    transduce(xform âˆ˜ typeset(), push!, InitOnly(), from)
  else
    transduce(xform, push!, to, from)
  end
end

function into!(to::Base.Vector, from; infertype=true)
  if isempty(to) && eltype(to) == Any && infertype
    transduce(typeset(), push!, InitOnly(), from)
  else
    reduce(push!, to, from)
  end
end
