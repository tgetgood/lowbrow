#+TITLE: Bundle of Experiments

The name comes from the fact that I was going to play with writing a toy
browser. It has since gone in several very different directions, all of which
are tending to lower and lower levels.

DataStructures is a persistent data structure library (mostly a partial copy of
Clojure's data structures). The initial implementation worked well but performed
abysmally, recent rewrites have improved things, but performance is acceptable
at best. This subproject alternates between developing the language I want to
program a game engine in and low level fiddling to make them fast enough to use
in a game engine.

HLVK (High Level Vulkan) is a toy game engine. It works, most of the time, and
performs reasonably when working. The demos are all very simple, and there is an
unbounded list of features that are useful, or would be informative to
implement.

src/browser is the humblest beginnings of a working browser. It can fetch HTML
and dump it to a terminal. That's about it. I didn't want to use GTK, and I've
always wanted to learn Vulkan properly, so this hobby project took a hard turn.
* Fail notes
** [2023-12-19 Tue]
   Just spent 20 minutes debugging a null pointer error through the mandlebrot
   demo and HLVK.

   The core issue was that vk couldn't create a device because I wanted a
   feature that wasn't available on the hardware. That did not — and does not —
   cause any error. In fact, none of the checks in hardware.checkdevice trigger
   any sort of error, they just return null.

   The null also propagated up through pdevice and caused the npe in
   createdevice when it tried to read out the queues.

   Possible solution: have `checkdevice` take a map of tests and return a map of
   results. Then, when a device is rejected, we have a clear reason why.

   Better solution: Finally refactored the entire hardware negotiation system to
   actually negotiate, that is, pass in a data description of what you want, get
   back a data description of what's possible on the hardware, decide whether to
   go ahead or abort. This is nice in that it allows the programmer to initially
   ask the impossible without crashing the system (so long as they don't
   actually try to do it), and then back off until they meet the hardware
   somewhere in the middle. When that's actually possible, of course.
** [2023-12-19 Tue 22:47]
   Bug involving descriptorsets not being set properly comes down to a magic
   line of code where I merge config with one of its submaps.

   Why? I have no idea. I suspect this is a half finished refactor.

   The real reason turns out to be keeping handles around to prevent GC. I need
   to take charge of freeing vk objects myself eventually. But I'm resisting as
   long as possible.
* To Do List
** wrap images to make transitions easier                       :ergonomics:
   Vulkan doesn't rememeber anything for you, which makes life unduly difficult.
** fix resizing                                                        :bug:
   Segfault when shrinking windows. Resizing is just disabled at present.
** Segfault on complete teardown and recreation                        :bug:
   Specifically the swapchain destructor segfaults.

   Almost never the first time, but always within 5 or 6 tries. Handles aren't
   being freed in the correct order most likely.
** exclusive buffers                                                   :opt:
   currently images are generally sharing mode exclusive and there's transition
   logic to load them then hand them off to graphics. It's not bad.

   So why are all buffers relegated to concurrent access? The speed degradation
   is not an issue yet, but it's not a hard thing to fix.

   Note: use VkBufferMemoryBarrier(2)
** Embrace the VkRender struct :opt:
   Having a fixed struct sort of violates my basic principle of accumulating
   state to create a uniform API.

   But I'm starting to run into some issues with handling hashmaps in hot spots
   like the render loop.

   Something like a clj record could be a nice interim solution, but really, if
   you want to work with C you need *closed* types, which clojure rejects pretty
   uniformly. You also need C compatible memory layouts.

   So why not embrace C structs, but wrap them in logic so that they can be
   accessed and maybe even extended as if they were maps (of course they won't
   still be structs then).

   The dream is to be able to spot maps with stable structure and transform them
   into structs as part of jit compilation. This is probably only really useful
   in hotspots, but would be a really cool optimisation to pull off.
** Deadlock in mandlebrot example                                      :bug:
   When interacting with the graphic long enough, eventually the return channel
   from the compute pipeline never receives a value and the render loop hangs.

   No errors appear to happen on any of the threads, though I could be failing
   to catch something.
** Mesh Shader Example                                                 :demo:
** Ray Tracing Example                                                 :demo:
* Copyright
  © 2024 Thomas Getgood
